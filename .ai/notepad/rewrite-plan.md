# CAF GPT Rewrite Plan: Go + HTMX + Templ in Docker

## 1. Project Overview

The current application is built with SvelteKit and TypeScript, using Cloudflare Workers for deployment. It provides two main features:
- PaceNoteFoo: Generates professional pace notes for Canadian Armed Forces members
- PolicyFoo: Answers questions about CAF policies

For the rewrite, we'll use:
- Go as the backend language
- HTMX for interactive front-end components without JavaScript frameworks
- Templ (Go template engine) for server-side rendering of HTML
- Fly.io for deployment
- TigrisData S3-compatible storage instead of R2

## 2. Project Structure

Following Fly.io's recommended Go patterns with embedded assets:

```
caf-gpt/
├── cmd/
│   └── cafgpt/
│       └── main.go              # Entry point with //go:embed directives
├── internal/
│   ├── handlers/                # HTTP handlers (pages + HTMX partials)
│   │   ├── pages.go             # Full page handlers (/pacenote, /policy, /)
│   │   ├── partials.go          # HTMX partial handlers
│   │   └── health.go            # Health check handler
│   ├── services/                # Business logic (internal only)
│   │   ├── ai_service.go        # AI service integration
│   │   ├── pacenote_service.go  # PaceNote business logic
│   │   └── policy_service.go    # Policy business logic
│   ├── storage/                 # Tigris S3 integration
│   │   └── tigris.go            # S3 client with Fly.io patterns
│   ├── config/                  # Configuration management
│   │   └── config.go            # Environment variables
│   └── templates/               # HTML templates (embedded via //go:embed)
│       ├── base/
│       │   ├── layout.html      # Base layout template
│       │   └── head.html        # Common head section
│       ├── pages/
│       │   ├── index.html       # Home page template
│       │   ├── pacenote.html    # PaceNote page template
│       │   └── policy.html      # Policy page template
│       └── partials/            # HTMX HTML fragments
│           ├── pacenote_form.html
│           ├── pacenote_results.html
│           ├── policy_form.html
│           └── policy_response.html
├── static/                      # Static assets (embedded via //go:embed)
│   ├── css/
│   │   └── app.css              # Main stylesheet
│   └── js/
│       └── htmx.min.js          # HTMX library
├── go.mod                       # Go module (will be auto-detected by Fly.io)
├── go.sum                       # Go dependencies
├── fly.toml                     # Generated by flyctl launch
├── Dockerfile                   # Generated by flyctl launch
└── README.md                    # Project documentation
```

### Key Fly.io Integration Points:

1. **Asset Embedding**: Templates and static files embedded in binary via `//go:embed`
2. **Auto-Detection**: `flyctl launch` will detect Go project and generate configs
3. **Standard Layout**: Following Go community conventions for discoverability
4. **Health Check**: Built-in `/health` endpoint for Fly.io monitoring

## 3. Architecture: HTML Partials with HTMX

### 3.1 Frontend-Backend Integration

**No Exposed APIs**: The backend never exposes business logic as JSON APIs. Instead:

- **Page Handlers**: Serve complete HTML pages (`/`, `/pacenote`, `/policy`)
- **Partial Handlers**: Return HTML fragments for HTMX requests
- **Form Submissions**: Process form data and return HTML partials
- **Health Check**: Only `/health` endpoint returns JSON (for monitoring)

### 3.2 HTMX Integration Pattern

```html
<!-- Example: PaceNote form submission -->
<form hx-post="/pacenote/generate" 
      hx-target="#results" 
      hx-swap="innerHTML"
      hx-indicator="#spinner">
  <!-- form fields -->
  <button type="submit">Generate PaceNote</button>
</form>

<div id="results">
  <!-- HTMX will inject HTML partial here -->
</div>
```

**Backend Response**: Returns HTML fragment, not JSON:
```html
<div class="results-container">
  <h3>Generated PaceNote</h3>
  <p>Your pace note content...</p>
</div>
```

### 3.3 URL Structure (Maintained)

- `/` → Home page
- `/pacenote` → PaceNote page (full HTML)
- `/pacenote/generate` → HTMX partial (HTML fragment)
- `/policy` → Policy page (full HTML)  
- `/policy/ask` → HTMX partial (HTML fragment)
- `/health` → Health check (JSON - only public API)

## 4. Implementation Strategy

### 4.1 Web Layer (No Exposed APIs)

- **Page Handlers**: Serve complete HTML pages with embedded HTMX
- **Partial Handlers**: Process forms and return HTML fragments
- **Internal Only**: Business logic never exposed as public endpoints
- **Security**: All processing happens server-side, HTML-only responses

### 4.2 Service Layer (Internal)

- Create service layers to handle business logic and AI interactions
- Implement functions to:
  - Generate pace notes with AI
  - Answer policy questions with AI  
  - Validate input data
  - Read/write from/to storage
- **Conversation State**: PolicyFoo conversation managed in browser (JavaScript)

## 5. Fly.io Deployment (Following Official Best Practices)

### 5.1 Key Insights from Fly.io Documentation

- **Template Embedding**: Use `//go:embed` for templates and static files (Go 1.16+)
- **Auto-Detection**: `flyctl launch` will scan Go source and auto-generate configuration
- **Standard Structure**: Fly.io expects standard Go project layout with `go.mod`
- **Health Checks**: Built-in health check support via `[[http_service.checks]]`
- **Tigris Integration**: Built-in support for Tigris S3-compatible storage

### 5.2 No Dockerfile Required! (Buildpacks)

Fly.io uses **buildpacks** for Go applications, which means:

- **No Dockerfile needed**: Fly.io auto-detects Go projects via `go.mod`
- **Automatic builds**: `flyctl launch` scans and configures everything
- **Optimized builds**: Built-in caching and optimization
- **Standard structure**: Just needs `go.mod` and standard Go layout

The official go-example repo structure:
```
go-example/
├── app.go              # Main application (or cmd/app/main.go)
├── go.mod              # Required for auto-detection
├── templates/          # Templates embedded via //go:embed
│   └── index.html.tmpl
└── README.md
```

**Key Point**: The `//go:embed` directive embeds all assets into the binary, so no file copying is needed during deployment.

### 5.3 Template Embedding Strategy

Using Go 1.16+ `//go:embed` directive in `main.go`:

```go
package main

import (
    "embed"
    "html/template"
    "net/http"
    "os"
)

//go:embed internal/templates/*
var templateFS embed.FS

//go:embed static/*
var staticFS embed.FS

var templates = template.Must(template.ParseFS(templateFS, "internal/templates/*.html"))

func main() {
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }
    
    // Serve static files
    http.Handle("/static/", http.FileServer(http.FS(staticFS)))
    
    // Register handlers
    http.HandleFunc("/", homeHandler)
    http.HandleFunc("/health", healthHandler)
    
    log.Printf("Server starting on port %s", port)
    log.Fatal(http.ListenAndServe(":"+port, nil))
}
```

### 5.4 fly.toml Configuration (Minimal Auto-Generated)

The `flyctl launch` command will generate a minimal `fly.toml`:

```toml
app = 'caf-gpt'
primary_region = 'yyz'  # Toronto for CAF users

[build]
  [build.args]
    GO_VERSION = '1.23'  # Auto-detected from go.mod

[env]
  PORT = '8080'

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = true
  auto_start_machines = true
  min_machines_running = 0

  # Health check endpoint
  [[http_service.checks]]
    grace_period = "10s"
    interval = "30s"
    method = "GET"
    timeout = "5s"
    path = "/health"

[[vm]]
  cpu_kind = 'shared'
  cpus = 1
  memory_mb = 1024
```

### 5.5 Deployment Process (Buildpack-Based)

1. **Project Setup**: 
   - Ensure `go.mod` exists (required for detection)
   - Use standard Go project structure
   - Embed assets with `//go:embed`

2. **Initialize**: 
   - `flyctl launch` (auto-detects Go via buildpack)
   - No Dockerfile needed!
   - Auto-generates optimized `fly.toml`

3. **Configure**: 
   - Customize `fly.toml` for Canadian region (YYZ)
   - Add health check endpoint
   - Set up Tigris: `fly storage create`

4. **Deploy**: 
   - `flyctl deploy` (buildpack handles compilation)
   - Monitor: `flyctl status`
   - Open: `flyctl apps open`

## 6. Tigris S3 Integration (Fly.io Native Support)

### 6.1 Tigris Setup via Fly.io

Fly.io provides native Tigris integration with automatic credential management:

```bash
# Create Tigris bucket (run in app directory)
fly storage create

# This automatically sets these secrets:
# AWS_ACCESS_KEY_ID
# AWS_SECRET_ACCESS_KEY  
# AWS_ENDPOINT_URL_S3: https://fly.storage.tigris.dev
# AWS_REGION: auto
# BUCKET_NAME
```

### 6.2 Go Implementation with AWS SDK v2

```go
// internal/storage/tigris.go
package storage

import (
    "context"
    "fmt"
    
    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/aws/aws-sdk-go-v2/service/s3"
)

func NewTigrisClient(ctx context.Context) (*s3.Client, error) {
    // Load AWS config from environment variables
    cfg, err := config.LoadDefaultConfig(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to load Tigris config: %w", err)
    }
    
    // Create S3 client configured for Tigris
    return s3.NewFromConfig(cfg, func(o *s3.Options) {
        o.BaseEndpoint = aws.String("https://fly.storage.tigris.dev")
        o.Region = "auto"
    }), nil
}
```

### 6.3 Required Dependencies

```bash
go get github.com/aws/aws-sdk-go-v2
go get github.com/aws/aws-sdk-go-v2/config  
go get github.com/aws/aws-sdk-go-v2/service/s3
```

## 7. Documentation

### 7.1 README.md

- Document the project structure, setup instructions, and usage
- Include information about:
  - Building and running the application
  - Environment variables required
  - How to use the features (PaceNoteFoo, PolicyFoo)
  - Docker commands for building and running containers

### 7.2 Code Comments

- Add comments to code where necessary to explain complex logic or important functionality

## 8. Implementation Steps (Buildpack Approach)

1. **Project Initialization**
   - Create Go module: `go mod init caf-gpt`
   - Set up standard Go project structure (no Dockerfile needed!)
   - Implement `//go:embed` for templates and static files

2. **Core Development**
   - Implement HTTP server with template embedding
   - Create service layer for business logic (internal only)
   - Add HTMX integration for interactive components

3. **Fly.io Integration (Buildpack)**
   - Run `flyctl launch` for auto-configuration via buildpacks
   - Customize `fly.toml` for Canadian region
   - Set up Tigris storage: `fly storage create`

4. **Testing & Deployment**
   - Local testing with `go run ./cmd/cafgpt` (or `go run app.go`)
   - Deploy with `flyctl deploy` (buildpack compiles automatically)
   - Monitor with `flyctl status`

5. **Documentation & Polish**
   - Update README.md with Go-specific instructions
   - Add code comments and examples
   - Test all HTMX interactions

## 9. Security & Architecture Benefits

- **No API Exposure**: Business logic never exposed as public endpoints
- **HTML-Only Responses**: Backend returns HTML fragments, never JSON APIs
- **Server-Side Security**: All processing happens server-side
- **HTMX Integration**: Interactive frontend without exposing backend
- **Browser State Management**: Conversation state handled client-side
- **Single Health Endpoint**: Only `/health` returns JSON for monitoring

## 10. AI Agent Rules & File Preservation

### 10.1 Read-Only Files (DO NOT EDIT)

The following files must be preserved as read-only and never modified by AI agents:

- **Prompt Files**: All `.md` files in service prompt directories
  - `src/lib/services/paceNote/prompts/*.md`
  - `src/lib/services/policyFoo/doadFoo/prompts/*.md`
  - `src/lib/services/policyFoo/leaveFoo/prompts/*.md`
  
- **AI Rules**: All files in the AI rules directory
  - `.ai/rules/*.md`

### 10.2 Migration Strategy for Prompts

When rewriting to Go, these prompt files should be:

1. **Copied as-is** to the new Go structure:
   ```
   internal/services/
   ├── pacenote/
   │   └── prompts/
   │       └── base.md           # Copy from current location
   ├── policy/
   │   ├── doad/
   │   │   └── prompts/
   │   │       ├── DOAD-list-table.md
   │   │       ├── finder.md
   │   │       └── main.md
   │   └── leave/
   │       └── prompts/
   │           └── main.md
   ```

2. **Embedded via `//go:embed`** for runtime access:
   ```go
   //go:embed internal/services/*/prompts/*.md
   var promptFS embed.FS
   ```

3. **Never modified** by AI agents - these are carefully crafted domain-specific prompts

